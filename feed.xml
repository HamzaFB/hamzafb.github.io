<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://hamzafb.github.io//feed.xml" rel="self" type="application/atom+xml" /><link href="https://hamzafb.github.io//" rel="alternate" type="text/html" /><updated>2022-09-12T23:07:08+00:00</updated><id>https://hamzafb.github.io//feed.xml</id><title type="html">Data Science Blog</title><author><name>Hamza FILALI</name></author><entry><title type="html">Notes on Bayesian Online Change Point Detection</title><link href="https://hamzafb.github.io//notes-on-bayesian-online-change-point-detection/" rel="alternate" type="text/html" title="Notes on Bayesian Online Change Point Detection" /><published>2022-09-04T00:00:00+00:00</published><updated>2022-09-04T00:00:00+00:00</updated><id>https://hamzafb.github.io//notes-on-bayesian-online-change-point-detection</id><content type="html" xml:base="https://hamzafb.github.io//notes-on-bayesian-online-change-point-detection/"><![CDATA[<p>In this post I am going to delve into the mathematical details behind the graphical model <em>Bayesian Online
Change Point Detection</em> introduced in <a class="citation" href="#adams2007bayesian">(Adams &amp; MacKay, 2007)</a>.
This model can be used to detect different type of change-points and has known many extensions over the last few years.<br />
Given a time series, we are interested in detecting structural changes
as new data comes in <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.<br />
A great explanation of this paper can be found in <a class="citation" href="#gundersen">(Gundersen, 2022)</a>.<br />
You might ask, why reading this post then? There is three main reasons.<br />
First, I will try to clarify parts that were not trivial to me despite
reading the paper and the post above (e.g. a tiny mistake was made in the math
derivation).<br />
Second and most importantly the paper only provides a way to calculate
the probability that there was a change-point k units of time ago, but
it does not propose a strategy to segment the time-series. I will
suggest an algorithm to perform an optimal segmentation at a given time t.
Finally, I will show how we can use BOCPD to detect trend changes.</p>

<figure>
<a name="graphicalmodel">
</a>
<img src="../images/bocpd_graphical_model.png" alt="Trulli" style="width:100%" />
<figcaption align="center"><b>Graphical model associated to BOCPD. Source
<a class="citation" href="#kim2015reading">(Kim &amp; Choi, 2015)</a></b></figcaption>
</figure>

<h1 id="bocpd">BOCPD</h1>

<p>Let \(\{x_{1}, ... x_{T}\}\in \mathbf{R}^{T\times d}\) denote the time
series of interest.</p>

<h2 id="introducing-the-main-ingredient-run-length">Introducing the main ingredient: Run-length</h2>

<p>Let \(r_{t}\), the <em>run-length</em>, be a random variable that represent the
time since the last change-point. For instance, \(r_{t} = j\) implies that
the last change-point was at time t-j.<br />
It follows that \(r_{t} \in \mathbf{R}^{t}\) and \(r_{t} = \begin{cases}
0 \text{     if change-point at time $t$} \\
r_{t-1} + 1 \text{     else} \end{cases}\)</p>

<p><br />
In the BOCPD model, our main interest lies in calculating the run-length
posterior distribution \(P(r_{t}|x_{1:t})\).<br />
In order to do compute it we need to make some assumptions around:</p>

<ol>
  <li>
    <p>the conditional dependence structure between \(\{x_{1}, ... x_{T}\}\)
and \(\{r_{1}, ... r_{T}\}\)</p>
  </li>
  <li>
    <p>the underlying distribution of \(\{x_{1}, ... x_{T}\}\) and
\(\{r_{1}, ... r_{T}\}\)</p>
  </li>
</ol>

<h2 id="conditional-dependence-structure-assumptions">Conditional dependence structure assumptions</h2>

<p>The assumptions that we are going to explain in more details are
outlined in the <a href="#graphicalmodel">graphical representation above</a>.</p>

<p><ins>Assumption 1:</ins> We assume that \(r_{t}\) is conditionally
independent of everything else given \(r_{t-1}\). In particular, \(P(r_{t} | r_{t-1}, x_{1:t}) = P(r_{t} | r_{t-1})\)</p>

<p><ins>Assumption 2:</ins> We assume that the current observation only
depends on the past observations associated to the current partition
defined be the run-length, i.e.
\(P(x_{t} | r_{t-1}=r, x_{1:t-1}) = P(x_{t} | x_{t-r-1:t-1})\)</p>

<p>With these two assumptions, we can derive our main objective
\(P(r_{t}|x_{1:t})\).<br />
Given that \(P(r_{t}|x_{1:t}) = \frac{P(r_{t},x_{1:t})}{\sum_{r'_{t}}P(r'_{t},x_{1:t})} \tag{1}\),
we just need to solve for \(P(r_{t},x_{1:t})\).</p>

<p>\(\begin{aligned}
P(r_{t},x_{1:t}) =&amp; \sum_{r_{t-1}} P(r_{t}, r_{t-1}, x_{1:t})  \text{      (by marginalizing over $r_{t-1}$)}\\ =&amp; \sum_{r_{t-1}} P(r_{t}, x_{t} | r_{t-1}, x_{1:t-1})P(r_{t-1}, x_{1:t-1}) \text{     (by bayes rule)}\\ =&amp;  \sum_{r_{t-1}} P(r_{t}| x_{t} , r_{t-1}, x_{1:t-1})  P( x_{t} | r_{t-1}, x_{1:t-1}) P(r_{t-1}, x_{1:t-1}) \text{      (by bayes rule)} \\ =&amp;  \sum_{r_{t-1}} P(r_{t}|  r_{t-1})  P( x_{t} | r_{t-1}, x_{t-1- r_{t-1}:t-1}) P(r_{t-1}, x_{1:t-1}) \quad \text{ (by assumption 1 and 2)}
\end{aligned}\)<br />
Three terms appear in the equations above:</p>

<p>\(P(r_{t},x_{1:t}) = \sum_{r_{t-1}} \underbrace{P(r_{t}|  r_{t-1})}_{\text{Change-point Prior}}   \underbrace{P( x_{t} | r_{t-1}, x_{t-1- r_{t-1}:t-1})}_{\text{Predictive Model}} \underbrace{P(r_{t-1}, x_{1:t-1})}_{\text{Message}}\)<br />
We now need to make assumptions on the distribution of the Change-point
Prior and the Underlying Predictive Model in order to be able to
recursively derive the run-length posterior.</p>

<h2 id="underlying-distribution-assumptions">Underlying distribution assumptions</h2>

<h3 id="change-point-prior-model">Change-point prior model</h3>

<p>The transition probability \(P(r_{t}|r_{t-1})\) is assumed to follow the
below distribution:</p>

\[P(r_{t}|r_{t-1}) = \begin{cases}
H(r_{t-1} + 1) \quad \text{if   } r_t = 0
\\
1 - H(r_{t-1} + 1) \quad \text{if }r_t = r_{t-1} + 1
\\
0 \quad \text{otherwise}
\end{cases}\]

<p>where  \(H(\tau) = \frac{p_{g}(\tau)}{\sum_{t=\tau}^{\infty}p_{g}(t)}\) is the
hazard function<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup> and \(p_{g}(t)\) represents the probability of a
segment of length t.</p>

<p>If we set \(p_{g}\) to follow a geometric
distribution with parameter \(\lambda\) then
\(H(\tau) = \frac{1}{\lambda}\). 
The prior \(\lambda\) encodes our belief on
the expected length of a segment, in other words our prior on the
average length of a partition.</p>

<h3 id="predictive-model-assumptions">Predictive Model assumptions</h3>

<p>The last part we need to compute is the predictive probability
\(P( x_{t} | r_{t-1}, x_{t-1- r_{t-1}:t-1})\).<br />
<br />
<ins>Assumption 3:</ins> We assume that \(x_{t}\) follows a
distribution with parameter \(\eta\) (where \(\eta\) is a random quantity in
a bayesian framework). \(\eta\) is shared across all the \(x_{i}\) within a
segment (defined by the run-length).</p>

<p>Given our new point, we are trying to estimate the probability that this
new point belongs to the current partition: 
\(P( x_{t} | r_{t-1}, x_{t-1- r_{t-1}:t-1}) = \int P( x_{t} | \eta, r_{t-1}, x_{t-1- r_{t-1}:t-1}) P( \eta | r_{t-1}, x_{t-1- r_{t-1}:t-1})d \eta\)<br />
<br />
<ins>Assumption 4:</ins>
\(x_{t} \perp\kern-5pt\perp  r_{t-1}, x_{t-1- r_{t-1}:t-1} |\eta\).<br />
<br />
Under this assumption, we obtain:</p>

<p>\(P( x_{t} | r_{t-1}, x_{t-1- r_{t-1}:t-1}) = \int \underbrace{P( x_{t}| \eta)}_\text{underlying model}  \underbrace{P( \eta | r_{t-1}, x_{t-1- r_{t-1}:t-1})}_{\text{Posterior Distribution}}d \eta\)<br />
We now need to define the underlying distribution of our time series and the
distribution of the prior \(\eta\).</p>

<p>The law \(x_{t} | \eta\) that we choose defines the type of change-points
we wish to detect.<br />
If we are interested in detecting abrupt shifts in the mean, we could
then choose a Gaussian distribution.<br />
If we have count data, we could be tempted to choose a Poisson
distribution. If we have are interested in changes in the trend, we
could choose a Bayesian linear regression with time as a regressor.<br />
<br />
In <a class="citation" href="#adams2007bayesian">(Adams &amp; MacKay, 2007)</a>, \(x_{t}| \eta\) is restricted to come from
the Exponential Family and the prior \(P(\eta)\) is restricted to be a
conjugate prior (which means that
\(P( \eta | r_{t-1}, x_{t-1- r_{t-1}:t-1})\) and \(P(\eta)\) come from the
same family distribution).<br />
<br />
The choice of Exponential family + conjugate prior is motivated by a
trade-off between tractability of the equations and generalization over
the type of change-points that can be detected:</p>

<ol>
  <li>
    <p>The conjugate prior allows for a tractable derivation of the
posterior distribution as we obtain a closed-form of the posterior
distribution. The main derivation needed is on the hyper-parameters
associated with the posterior distribution. In the case of an
Exponential Family likelihood, the hyper-parameters have an easy
formula that can be updated sequentially, a very appealing property
in the case of sequential learning.</p>
  </li>
  <li>
    <p>The Exponential Family encompasses a lot of widely used family for
change-point detection problems (e.g. normal distribution, poisson
distribution, bayesian linear regression...).</p>
  </li>
  <li>
    <p>Most of the exponential family distributions lead to a closed form
of the predictive probability when the prior is conjugate, which
avoids us to resort to bayesian approximation techniques that are
computationally costly.</p>
  </li>
</ol>

<h1 id="how-can-we-use-the-output-of-bocpd-to-detect-changes">How can we use the output of BOCPD to detect changes?</h1>

<h2 id="an-offline-strategy-a-viterbi-like-algorithm">An offline strategy: a viterbi-like algorithm</h2>

<p>A natural criteria to find the best segmentation up until time t is to
find the Maximum A Posteriori sequence of run-length, i.e. the most
probable sequence of run-length:</p>

\[r^{*}_{1}, ... r^{*}_{t} = \arg \max\limits_{r_{1}, ... r_{t}} P(r_{1}, ... r_{t} | x_{1}, ..., x_{t})\]

<p>By noticing that:  \(\arg \max\limits_{r_{1}, ... r_{t}} P(r_{1}, ... r_{t} | x_{1}, ..., x_{t}) =  \arg \max\limits_{r_{1}, ... r_{t}} P(r_{1}, ... r_{t} , x_{1}, ..., x_{t})\)<br />
We will optimize \(P(r_{1}, ... r_{t} , x_{1}, ..., x_{t})\) through a dynamic programming algorithm.</p>

<p>This optimization formulation is the same as the Viterbi Algorithm used
for Hidden Markov Models (see e.g. chapter 17 of <a class="citation" href="#murphy2012machine">(Murphy, 2012)</a>).</p>

<p>However, the structural dependencies are slightly different, hence the
recursion is slightly different.</p>

<p>Figure <a href="#graphicalmodel">1</a> illustrates the structural dependencies assumptions in BOCPD, which are used in the last line of the equation below.</p>

\[\begin{aligned}
    P(r_{1}, ..., r_{t} , x_{1}, ..., x_{t}) =&amp; P( r_{t} | r_{1}, ..., r_{t-1}, x_{1}, ..., x_{t}) P(r_{1}, ..., r_{t-1}, , x_{1}, ..., x_{t}) \\ =&amp; P( r_{t} | r_{1}, ..., r_{t-1}, x_{1}, ..., x_{t}) P( x_{t} | r_{1}, ..., r_{t-1}, x_{1}, ..., x_{t-1}) P(r_{1}, ..., r_{t-1} , x_{1}, ..., x_{t-1})
    \\ =&amp; P( r_{t} | r_{t-1}) P( x_{t} | r_{t-1}, x_{1}, ..., x_{t-1}) P(r_{1}, ..., r_{t-1} , x_{1}, ..., x_{t-1}) \text{  (under assumptions 1 and 2)}
\end{aligned}\]

<p>Now let’s introduce a few notations:<br />
Let
\(\delta_{t}(j) \overset{\Delta}{=}  \log P(r_{1}, ..., r_{t}=j, x_{1}, ..., x_{t})\).<br />
Let \(A(i,j)  \overset{\Delta}{=} \log P(r_{t}=j|r_{t-1}=i)\).<br />
Let
\(\lambda_{t}(i)  \overset{\Delta}{=} \log P( x_{t}| r_{t-1}=i, x_{1}, ..., x_{t-1})\).</p>

<p>Using the equation above, we get:<br />
\(\delta_{t}(j) = \max\limits_{i} A(i,j) + \lambda_{t}(i) +\delta_{t-1}(i)\)</p>

<p>This recursion above allows us to compute the optimal sequence of
run-length at each time step.</p>

<p>Because \(r_{t} = \begin{cases}
0 \text{     if change-point at time $t$} \\
r_{t-1} + 1 \text{     otherwise} \end{cases}\), it follows that:</p>

\[\delta_{t}(j) =  \begin{cases}
A(j-1,j) + \lambda_{t}(j-1) +\delta_{t-1}(j-1) \text{       for    } j \in \left[\!\!\left[1 , t \right]\!\!\right] \\
\max\limits_{i} A(i,j) + \lambda_{t}(i) +\delta_{t-1}(i) \text{       if     } j=0 \end{cases}\]

<h3 id="computational-aspects">Computational aspects</h3>
<p>An important drawback is the time and space complexity of this
algorithm. The space complexity is \(O(T^{2})\) while the time complexity is
\(O(T^{2})\).</p>

<h2 id="an-online-strategy">An online strategy</h2>

<p>In the online change-point setting, we are above all interested in
detecting a new change-point with minimum delay (more than finding
retrospectively the optimal segmentation).<br />
An easy and natural strategy would be to detect an alert if the
run-length posterior distribution
\(P(r_{t} = l| x_{1}, ..., x_{t}) &gt; \text{threshold}\).<br />
There is two parameters to consider here. 
The parameter \(l\) directly encodes the detection delay with which we will flag a change-point. 
The threshold encodes the confidence degree with which we will flag a
change-point.<br />
One issue with this methodology is that we will generally detect
multiple consecutive change-points.</p>

<h1 id="references">References</h1>

<ol class="bibliography"><li><span id="adams2007bayesian">Adams, R. P., &amp; MacKay, D. J. C. (2007). Bayesian online changepoint detection. <i>ArXiv Preprint ArXiv:0710.3742</i>.</span></li>
<li><span id="gundersen">Gundersen, G. (2022). <i>Bayesian Online Changepoint Detection</i>. https://gregorygundersen.com/blog/2019/08/13/bocd/</span></li>
<li><span id="kim2015reading">Kim, T., &amp; Choi, J. (2015). Reading documents for bayesian online change point detection. <i>Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing</i>, 1610–1619.</span></li>
<li><span id="murphy2012machine">Murphy, K. P. (2012). <i>Machine learning: a probabilistic perspective</i>. MIT press.</span></li></ol>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Online detection is opposed to Offline change-point detection. In
the offline case, we are interested in identifying structural
changes after observing the entire time series. The online case aims
at identifying structural changes as new observations come in. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>A term coming from the field of survival analysis <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>[&quot;Hamza FILALI&quot;]</name></author><category term="bayesian" /><category term="change-point" /><category term="online change-point" /><summary type="html"><![CDATA[In this post I am going to delve into the mathematical details behind the graphical model Bayesian Online Change Point Detection introduced in (Adams &amp; MacKay, 2007). This model can be used to detect different type of change-points and has known many extensions over the last few years. Given a time series, we are interested in detecting structural changes as new data comes in 1. A great explanation of this paper can be found in (Gundersen, 2022). You might ask, why reading this post then? There is three main reasons. First, I will try to clarify parts that were not trivial to me despite reading the paper and the post above (e.g. a tiny mistake was made in the math derivation). Second and most importantly the paper only provides a way to calculate the probability that there was a change-point k units of time ago, but it does not propose a strategy to segment the time-series. I will suggest an algorithm to perform an optimal segmentation at a given time t. Finally, I will show how we can use BOCPD to detect trend changes. Online detection is opposed to Offline change-point detection. In &#8617;]]></summary></entry></feed>